import { Check, GetMessage, Comparator, Value, Next, Done, Fail, Tuple } from './types';
export declare abstract class Validator<T> {
    parent?: this;
    check: Check<T>;
    getMessage: GetMessage<T>;
    comparator: Comparator<T>;
    constructor(check: Check<T>, parent?: Validator<T>, getMessage?: GetMessage<T>);
    protected abstract getComparator(a: T, b: T): number;
    protected abstract parse(value: any): any;
    protected abstract isValid(parsed: any, value: any): parsed is T;
    protected newInstance(): this;
    message(getMessage: GetMessage<T> | string): this;
    withComparator(comparator: Comparator<T>): this;
    reverseComparator(): this;
    validate(check: Check<T>): this;
    transform<R, V extends Validator<R>>(transformer: (value: T) => R | Promise<R>): V;
    eval(required: Value<boolean>, defaults?: Value<T>): this;
    required(defaults?: Value<T>): this;
    optional(defaults?: Value<T>): this;
    is(check: (value: T) => boolean | Promise<boolean>): this;
    oneOf(values: Value<T[]>): this;
    notOneOf(values: Value<T[]>): this;
    equals(compareTo: Value<T>): this;
    lessThan(compareTo: Value<T>): this;
    lessThanEqual(compareTo: Value<T>): this;
    max(compareTo: Value<T>): this;
    greaterThan(compareTo: Value<T>): this;
    greaterThanEqual(compareTo: Value<T>): this;
    between(min: Value<T>, max: Value<T>): this;
    min(compareTo: Value<T>): this;
    fail(): this;
    or(getMany: (validator: this) => this[]): this;
    json(): this;
    nullify(): this;
    remove(): this;
    set(newValue: Value<T>): this;
    run(value: any, next: Next<T>, done: Done<T>, fail: Fail<T>): Promise<void>;
    runAsTuple(value: any): Promise<Tuple<T>>;
    runAsPromise(value: any): Promise<T>;
}
